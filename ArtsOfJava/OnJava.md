# On Java

## PART I

1. Small Talk 是历史上第一门获得成功的面向对象语言，并为之后的Java提供了灵感。
2. Small Talk具备五个关键特征：
    1. 万物皆对象。
    2. 一段程序实际上是多个对象通过消息来通知彼此要干什么。
    3. 从内存角度来说，每一个对象都是由其他更为基础的对象构成的。
    4. 每一个对象都有类型。
    5. 同一类型的对象可以接受相同的消息。
3. 有史以来第一门面向对象编程语言是Simula-67，Simula-67引入了“类别”的概念，并允许通过class关键字自定义类型。
4. 在is-a关系中，子类没有对基类做拓展，只是重写了基类中的方法，若如此，则可以直接使用子类对象替代基类对象，这将构成里氏替换（基类可以出现在任何子类出现的地方）。
5. 在is-like-a关系中，子类对基类做了拓展，这将不会满足里氏替换原则，你将无法通过基类获取到子类拓展的成员。
6. 前期绑定：一般非面向对象编译器会生成对具体方法名的调用，方法名就决定了被执行代码的绝对地址，但是对于多态，代码地址需要在运行时才能明确。
7. 后期绑定：运行时再确定调用的代码，编译器在编译期确保方法真实存在，并且进行签名检查。Java使用存储在对象中的信息来计算方法体的地址。
8. 在有些语言中，方法并非默认具备动态绑定特性，如C++使用virtual实现后期绑定，但过Java默认具备动态绑定特性。
9. 向下转型、类型检查都需要额外的时间开销，自JDK5，添加的参数化类型可以解决旧版本因集合使用Object触发向下转型而引发的性能问题。
10. 对象的两个本质问题：存储在哪？如何控制生命周期？
11. 关于对象存储在哪？为了最大化运行时效率，分别使用使用栈区（自动变量、局部变量）保存对象引用，在堆上存储对象，在堆上存储对象牺牲灵活性。
12. 动态进行堆内存分配的开销更大。
13. 除了基本类型外，Java仅允许动态分配内存
14. Java只通过引用传递
15. 常见存储空间：
     1. 寄存器 Register，除了C、C++，一般无法直接控制寄存器的分配
     2. 栈向下生长，RAM，在栈上分配的对象必须在创建的时候明确生命周期，一般用于存储对象引用，对象的本体不在于此。
     3. 堆，使用通用内存池，也是RAM，存放全部的Java对象
     4. 常量存储，常量直接保存在程序代码中，常量可以存储在ROM中，常量存储一般和其他代码隔离开。
     5. 非RAM存储，持久化对象及序列化对象
16. 基本类型以自动变量的形式存储在栈上，通过包装类将基本类型呈现为堆上的原始对象。
17. 高精度数字：BigInteger、BigDecimal分别对应高精度int、高精度float，但是使用方法代替运算符，可以表示任意精度的整数、任意精度的浮点数。
18. Java在运行时对数组进行边界检查，验证索引的正确性。
19. 引用在超出作用域之后会消失，但是对象会一直存在。
20. 垃圾收集器监视所有通过new创建的对象，以字段身份出现的基本类型变量一定会被初始化为默认值，但此种机制不适用于局部变量，局部变量不赋初始值将导致编译错误。
21. 方法签名 = 方法名称 + 参数列表，方法签名是区分方法的唯一标识符
22. Q：向前引用？
23. public方法可以被外部程序调用
24. ==和!=比较引用是否相同，Integer、Byte、Long、Short存在缓存，-127~128
25. equals（重写后）比较真值，若不对equals重写，equals的默认行为就是==
26. 享元模式（Flyweight Patern），是一种结构型设计模式
27. Integer.valufOf效率高于new Integer的原因在于缓存，若命中缓存直接返回，而new则每次都会新建，Since JDK9，new Integer已废除。
28. && || 双个的逻辑运算符具备短路特性。
29. 字面量 literal value。
30. 使用0x或0X引导十六进制字面量，使用0引导八进制字面量，使用0b引导二进制字面量（Since JDK7）。
31. Since JDK7，可以在字面量中使用下划线，但有所限制：开头结尾、引导符号附近不可以出现下划线。
32. 位运算 & | ~ ^。
33. boolean不可取反，不可参与移位运算，具体的大小于JVM实现有关。
34. << 按位左移，>> 有符号右移，依照符号位高位补0或1，>>>无符号右移，无视符号，全补0。
35. 移位运算中右侧操作数只取低5位，若对long类型施加移位运算，则只取低6位。
36. 参与移位运算的byte、char、short会被提升为int，此时重新赋回byte、char、short时不会产生编译时错误，但会对值做截断，有可能导致数值异常。
37. boolean无法进行任何类型转换、class也无法进行类型转换。
38. Since JDK5，引入for-in语法，推荐在数组和容器中使用。
39. Since JDK8，可以使用forEach()方法。
40. 任何时候调用return都会直接导致方法退出。
41. 编译器同等的对待while和for(;;)。
42. 对最外层的迭代可以使用标签引导，引导需要放置在迭代的正上方，然后就可以使用break、continue实现整个迭代的标签跳转
43. switch可以使用整数选择器 integral-selector，所谓整数选择器，是一个可以生成整数的表达式。
44. Before JDK7，必须使用整数选择器，byte、short、char、int、long及其包装类。
45. Since JDK7，可以使用String作为选择器。
46. 默认构造器，无参数构造器，零参数构造器 zero-argument cons
47. 基本类型重载：基本数据类型重载会优先选择签名类型相同的方法，如果不存在与实际参数类型相同的方法，则调用类型提升的方法。eg：传递byte作为参数，此时若没有接受byte参数的方法，则调用int、long参数的方法。
48. 窄化转型必须显式进行，但提升转型可能自动进行。
49. 若不定义构造器，编译器将自动为类添加一个零参构造器，若手动定义了任何一个构造器，编译器将认为不需要自动生成零参构造器，不会默认添加。
50. 只在有必要的地方做必要的事情，一致、直观。
51. 在一个构造函数中只可以通过this+参数表调用其他构造器一次。
52. 在非构造函数中调用构造函数是不被允许的。
53. 若代码中大量使用static方法，需要重新考虑设计是否优秀。
54. 若对象在未使用new的情况下分配了一块特殊内存或资源，垃圾收集器只知道如何释放由new分配的内存，所以那些特殊内存或资源，无法由垃圾收集器进行回收。
55. “期望在垃圾收集前做一些事情”，这就是finalize的价值，但是永远不要显式使用它。
56. finalize不是析构函数、垃圾收集也并非析构。
57. 我创建了一个对象，这个对象在屏幕上绘制自己（占用屏幕资源），垃圾收集只会释放该对象占用的内存而不会释放屏幕资源，这时候需要在finalize中调用擦除屏幕的方法。
58. 垃圾收集仅与内存有关。
59. Java只能通过本地方法调用C/C++代码，但是C/C++可以调用其他语言代码，若在Java中通过本地方法经由malloc分配了内存，这部分内存就不会被Java的垃圾收集回收，必须在finalize中再通过本地方法调用free才能避免这部分内存泄露发生。
60. 所谓“本地对象”，是C++中的概念，Java并不如此做。在C++中，可以在栈上创建对象，这种对象在离开作用域后会被立刻销毁。
61. 垃圾收集和finalize都并不一定保证发生，JVM在内存充裕的时候有相当大的可能不会浪费时间去做垃圾收集。
62. 